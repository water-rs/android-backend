package dev.waterui.android.ffi;

import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;
import org.bytedeco.javacpp.tools.*;

/**
 * JavaCPP Parser configuration for waterui.h.
 * 
 * This file configures the JavaCPP Parser to generate Java bindings from the
 * C header file generated by Rust's cbindgen. The generated WaterUILib.java
 * provides low-level access to all WaterUI FFI functions including callbacks.
 */
@Properties(target = "dev.waterui.android.ffi.WaterUILib", value = @Platform(include = "waterui.h", includepath = {
        "src/main/cpp/" }, library = "waterui_app"))
public class WaterUIConfig implements InfoMapper {

    @Override
    public void map(InfoMap infoMap) {
        // ============================================================
        // Opaque pointer types - treat as Pointer
        // These are forward-declared structs with no definition exposed
        // ============================================================
        infoMap.put(new Info(
                // Core types
                "WuiEnv", "WuiAnyView", "WuiAnyViews", "WuiAction",
                "WuiColor", "WuiFont", "WuiLayout", "WuiDynamic",
                "WuiRendererView", "WuiTabContent",

                // Binding types
                "Binding_AnyView", "Binding_Color", "Binding_Font", "Binding_Id",
                "Binding_Str", "Binding_bool", "Binding_f32", "Binding_f64", "Binding_i32",
                "WuiBinding_AnyView", "WuiBinding_Color", "WuiBinding_Font", "WuiBinding_Id",
                "WuiBinding_Str", "WuiBinding_Volume", "WuiBinding_bool",
                "WuiBinding_f32", "WuiBinding_f64", "WuiBinding_i32",

                // Computed types
                "WuiComputed_AnyView", "WuiComputed_AnyViews_AnyView", "WuiComputed_Color",
                "WuiComputed_ColorScheme", "WuiComputed_Font", "WuiComputed_Id",
                "WuiComputed_LivePhotoSource", "WuiComputed_ResolvedColor", "WuiComputed_ResolvedFont",
                "WuiComputed_Str", "WuiComputed_StyledStr", "WuiComputed_Vec_PickerItem_Id",
                "WuiComputed_Vec_TableColumn", "WuiComputed_Video",
                "WuiComputed_bool", "WuiComputed_f32", "WuiComputed_f64", "WuiComputed_i32",

                // Watcher types - these are opaque but we need to pass them around
                "WuiWatcher_AnyView", "WuiWatcher_AnyViews_AnyView", "WuiWatcher_Color",
                "WuiWatcher_ColorScheme", "WuiWatcher_Font", "WuiWatcher_Id",
                "WuiWatcher_LivePhotoSource", "WuiWatcher_ResolvedColor", "WuiWatcher_ResolvedFont",
                "WuiWatcher_Str", "WuiWatcher_StyledStr", "WuiWatcher_Vec_PickerItem_Id",
                "WuiWatcher_Vec_TableColumn", "WuiWatcher_Video",
                "WuiWatcher_bool", "WuiWatcher_f32", "WuiWatcher_f64", "WuiWatcher_i32",

                // Guard and metadata
                "WuiWatcherGuard", "WuiWatcherMetadata").pointerTypes("Pointer"));

        // ============================================================
        // Enums - keep as int for simplicity
        // ============================================================
        infoMap.put(new Info(
                "WuiAnimation", "WuiAxis", "WuiFontWeight", "WuiKeyboardType",
                "WuiProgressStyle", "WuiRendererBufferFormat",
                "WuiColorScheme", "WuiColorSlot", "WuiFontSlot").valueTypes("int").pointerTypes("IntPointer"));

        // ============================================================
        // Struct mappings
        // ============================================================

        // WuiStr is a wrapper around WuiArray_u8
        infoMap.put(new Info("WuiStr").pointerTypes("WuiStr"));

        // Array types
        infoMap.put(new Info("WuiArray", "WuiArray_u8", "WuiArray_____WuiAnyView",
                "WuiArray_WuiProposalSize", "WuiArray_WuiChildMetadata",
                "WuiArray_WuiRect", "WuiArray_WuiStyledChunk",
                "WuiArray_WuiTableColumn", "WuiArray_WuiPickerItem").pointerTypes("Pointer"));

        // VTable types - skip these as they contain internal function pointers
        infoMap.put(new Info("WuiArrayVTable", "WuiArrayVTable_u8",
                "WuiArrayVTable_____WuiAnyView", "WuiArrayVTable_WuiProposalSize",
                "WuiArrayVTable_WuiChildMetadata", "WuiArrayVTable_WuiRect",
                "WuiArrayVTable_WuiStyledChunk", "WuiArrayVTable_WuiTableColumn",
                "WuiArrayVTable_WuiPickerItem").skip());

        // Slice types
        infoMap.put(new Info("WuiArraySlice", "WuiArraySlice_u8",
                "WuiArraySlice_____WuiAnyView", "WuiArraySlice_WuiProposalSize",
                "WuiArraySlice_WuiChildMetadata", "WuiArraySlice_WuiRect",
                "WuiArraySlice_WuiStyledChunk", "WuiArraySlice_WuiTableColumn",
                "WuiArraySlice_WuiPickerItem").pointerTypes("Pointer"));

        // ============================================================
        // Data structs - generate proper classes
        // ============================================================
        infoMap.put(new Info("WuiResolvedColor").pointerTypes("WuiResolvedColor"));
        infoMap.put(new Info("WuiResolvedFont").pointerTypes("WuiResolvedFont"));
        infoMap.put(new Info("WuiProposalSize").pointerTypes("WuiProposalSize"));
        infoMap.put(new Info("WuiSize").pointerTypes("WuiSize"));
        infoMap.put(new Info("WuiPoint").pointerTypes("WuiPoint"));
        infoMap.put(new Info("WuiRect").pointerTypes("WuiRect"));
        infoMap.put(new Info("WuiChildMetadata").pointerTypes("WuiChildMetadata"));
        infoMap.put(new Info("WuiId").pointerTypes("WuiId"));
        infoMap.put(new Info("WuiRange_f64").pointerTypes("WuiRange_f64"));
        infoMap.put(new Info("WuiRange_i32").pointerTypes("WuiRange_i32"));

        // View structs
        infoMap.put(new Info("WuiButton").pointerTypes("WuiButton"));
        infoMap.put(new Info("WuiText").pointerTypes("WuiText"));
        infoMap.put(new Info("WuiTextField").pointerTypes("WuiTextField"));
        infoMap.put(new Info("WuiToggle").pointerTypes("WuiToggle"));
        infoMap.put(new Info("WuiSlider").pointerTypes("WuiSlider"));
        infoMap.put(new Info("WuiStepper").pointerTypes("WuiStepper"));
        infoMap.put(new Info("WuiPicker").pointerTypes("WuiPicker"));
        infoMap.put(new Info("WuiPickerItem").pointerTypes("WuiPickerItem"));
        infoMap.put(new Info("WuiProgress").pointerTypes("WuiProgress"));
        infoMap.put(new Info("WuiScrollView").pointerTypes("WuiScrollView"));
        infoMap.put(new Info("WuiContainer").pointerTypes("WuiContainer"));
        infoMap.put(new Info("WuiFixedContainer").pointerTypes("WuiFixedContainer"));

        // Text styling
        infoMap.put(new Info("WuiTextStyle").pointerTypes("WuiTextStyle"));
        infoMap.put(new Info("WuiStyledChunk").pointerTypes("WuiStyledChunk"));
        infoMap.put(new Info("WuiStyledStr").pointerTypes("WuiStyledStr"));

        // ============================================================
        // Function pointer callbacks - define as FunctionPointer classes
        // ============================================================
        
        // Drop callback: void (*)(void*)
        infoMap.put(new Info("void (*)(void*)").pointerTypes("DropCallback"));
        
        // Watcher call callbacks for different types
        infoMap.put(new Info("void (*)(void*, bool, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallBool"));
        infoMap.put(new Info("void (*)(void*, int32_t, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallI32"));
        infoMap.put(new Info("void (*)(void*, float, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallF32"));
        infoMap.put(new Info("void (*)(void*, double, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallF64"));
        infoMap.put(new Info("void (*)(void*, struct WuiStr, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallStr"));
        infoMap.put(new Info("void (*)(void*, struct WuiStyledStr, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallStyledStr"));
        infoMap.put(new Info("void (*)(void*, struct WuiResolvedColor, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallResolvedColor"));
        infoMap.put(new Info("void (*)(void*, struct WuiResolvedFont, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallResolvedFont"));
        infoMap.put(new Info("void (*)(void*, int, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallColorScheme"));
        infoMap.put(new Info("void (*)(void*, struct WuiAnyView*, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallAnyView"));
        infoMap.put(new Info("void (*)(void*, struct WuiId, struct WuiWatcherMetadata*)").pointerTypes("WatcherCallId"));
        
        // Computed get/watch/drop callbacks
        infoMap.put(new Info("struct WuiResolvedColor (*)(void*)").pointerTypes("GetResolvedColor"));
        infoMap.put(new Info("struct WuiResolvedFont (*)(void*)").pointerTypes("GetResolvedFont"));
        infoMap.put(new Info("int (*)(void*)").pointerTypes("GetColorScheme"));
        infoMap.put(new Info("struct WuiWatcherGuard* (*)(void*, struct WuiWatcher_ResolvedColor*)").pointerTypes("WatchResolvedColor"));
        infoMap.put(new Info("struct WuiWatcherGuard* (*)(void*, struct WuiWatcher_ResolvedFont*)").pointerTypes("WatchResolvedFont"));
        infoMap.put(new Info("struct WuiWatcherGuard* (*)(void*, struct WuiWatcher_ColorScheme*)").pointerTypes("WatchColorScheme"));
        
        // VTable slice function
        infoMap.put(new Info("struct WuiArraySlice (*)(const void*)").skip());

        // NonNull is just void*
        infoMap.put(new Info("NonNull").valueTypes("Pointer"));

        // Url is an alias for WuiStr
        infoMap.put(new Info("Url").pointerTypes("WuiStr"));
    }
}
